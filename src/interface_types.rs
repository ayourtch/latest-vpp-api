/*
   Autogenerated Data, Do not Edit!
*/
#![allow(dead_code,unused_mut,unused_variables,unused_must_use,non_camel_case_types,unused_imports,non_snake_case)]
use vpp_api_macros::{VppMessage,VppUnionIdent};
use std::convert::TryInto;
use serde::{de::DeserializeOwned, Deserialize, Serialize};
pub use vpp_api_encoding::typ::*;
pub use vpp_api_encoding;
use vpp_api_message::VppApiMessage;
use serde_repr::{Serialize_repr, Deserialize_repr};
use typenum;
#[derive(Debug, Serialize, Deserialize, Clone, Copy, PartialEq)]
pub enum IfStatusFlags {
	 IF_STATUS_API_FLAG_ADMIN_UP=1,
	 IF_STATUS_API_FLAG_LINK_UP=2,
}
impl Default for IfStatusFlags {
	fn default() -> Self { IfStatusFlags::IF_STATUS_API_FLAG_ADMIN_UP }
}
impl AsEnumFlag for IfStatusFlags {
	 fn as_u32(data: &Self) -> u32{
		 *data as u32
	 }
	 fn from_u32(data: u32) -> Self{
		 match data{
			 1 => IfStatusFlags::IF_STATUS_API_FLAG_ADMIN_UP,
			 2 => IfStatusFlags::IF_STATUS_API_FLAG_LINK_UP,
			_ => panic!("Invalid Enum Descriminant")
		 }
	 }
	 fn size_of_enum_flag() -> u32{
		 32 as u32
	}
}
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)]
#[repr(u32)]
pub enum MtuProto {
	 MTU_PROTO_API_L3=0,
	 MTU_PROTO_API_IP4=1,
	 MTU_PROTO_API_IP6=2,
	 MTU_PROTO_API_MPLS=3,
}
impl Default for MtuProto {
	fn default() -> Self { MtuProto::MTU_PROTO_API_L3 }
}
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)]
#[repr(u32)]
pub enum LinkDuplex {
	 LINK_DUPLEX_API_UNKNOWN=0,
	 LINK_DUPLEX_API_HALF=1,
	 LINK_DUPLEX_API_FULL=2,
}
impl Default for LinkDuplex {
	fn default() -> Self { LinkDuplex::LINK_DUPLEX_API_UNKNOWN }
}
#[derive(Debug, Serialize, Deserialize, Clone, Copy, PartialEq)]
pub enum SubIfFlags {
	 SUB_IF_API_FLAG_NO_TAGS=1,
	 SUB_IF_API_FLAG_ONE_TAG=2,
	 SUB_IF_API_FLAG_TWO_TAGS=4,
	 SUB_IF_API_FLAG_DOT1AD=8,
	 SUB_IF_API_FLAG_EXACT_MATCH=16,
	 SUB_IF_API_FLAG_DEFAULT=32,
	 SUB_IF_API_FLAG_OUTER_VLAN_ID_ANY=64,
	 SUB_IF_API_FLAG_INNER_VLAN_ID_ANY=128,
	 SUB_IF_API_FLAG_MASK_VNET=254,
	 SUB_IF_API_FLAG_DOT1AH=256,
}
impl Default for SubIfFlags {
	fn default() -> Self { SubIfFlags::SUB_IF_API_FLAG_NO_TAGS }
}
impl AsEnumFlag for SubIfFlags {
	 fn as_u32(data: &Self) -> u32{
		 *data as u32
	 }
	 fn from_u32(data: u32) -> Self{
		 match data{
			 1 => SubIfFlags::SUB_IF_API_FLAG_NO_TAGS,
			 2 => SubIfFlags::SUB_IF_API_FLAG_ONE_TAG,
			 4 => SubIfFlags::SUB_IF_API_FLAG_TWO_TAGS,
			 8 => SubIfFlags::SUB_IF_API_FLAG_DOT1AD,
			 16 => SubIfFlags::SUB_IF_API_FLAG_EXACT_MATCH,
			 32 => SubIfFlags::SUB_IF_API_FLAG_DEFAULT,
			 64 => SubIfFlags::SUB_IF_API_FLAG_OUTER_VLAN_ID_ANY,
			 128 => SubIfFlags::SUB_IF_API_FLAG_INNER_VLAN_ID_ANY,
			 254 => SubIfFlags::SUB_IF_API_FLAG_MASK_VNET,
			 256 => SubIfFlags::SUB_IF_API_FLAG_DOT1AH,
			_ => panic!("Invalid Enum Descriminant")
		 }
	 }
	 fn size_of_enum_flag() -> u32{
		 32 as u32
	}
}
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)]
#[repr(u32)]
pub enum RxMode {
	 RX_MODE_API_UNKNOWN=0,
	 RX_MODE_API_POLLING=1,
	 RX_MODE_API_INTERRUPT=2,
	 RX_MODE_API_ADAPTIVE=3,
	 RX_MODE_API_DEFAULT=4,
}
impl Default for RxMode {
	fn default() -> Self { RxMode::RX_MODE_API_UNKNOWN }
}
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)]
#[repr(u32)]
pub enum IfType {
	 IF_API_TYPE_HARDWARE=0,
	 IF_API_TYPE_SUB=1,
	 IF_API_TYPE_P2P=2,
	 IF_API_TYPE_PIPE=3,
}
impl Default for IfType {
	fn default() -> Self { IfType::IF_API_TYPE_HARDWARE }
}
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)]
#[repr(u8)]
pub enum Direction {
	 RX=0,
	 TX=1,
}
impl Default for Direction {
	fn default() -> Self { Direction::RX }
}
pub type InterfaceIndex=u32;
