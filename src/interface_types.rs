/*
   Autogenerated Data, Do not Edit! 
*/
#![allow(dead_code,unused_mut,unused_variables,unused_must_use,non_camel_case_types,unused_imports,non_snake_case)]
use vpp_api_macros::{VppMessage,VppUnionIdent}; 
use std::convert::TryInto; 
use serde::{de::DeserializeOwned, Deserialize, Serialize};
pub use vpp_api_encoding::typ::*;
pub use vpp_api_encoding;
use vpp_api_message::VppApiMessage;
use serde_repr::{Serialize_repr, Deserialize_repr};
use typenum;
#[derive(Debug,Serialize, Deserialize, Clone, Copy)] 
pub enum IfStatusFlags { 
	 IF_STATUS_API_FLAG_ADMIN_UP=1, 
	 IF_STATUS_API_FLAG_LINK_UP=2, 
} 
impl Default for IfStatusFlags { 
	fn default() -> Self { IfStatusFlags::IF_STATUS_API_FLAG_ADMIN_UP }
}
impl AsEnumFlag for IfStatusFlags {
	 fn as_u32(data: &Self) -> u32{
		 *data as u32
	 }
	 fn from_u32(data: u32) -> Self{
		 match data{
			 1 => IfStatusFlags::IF_STATUS_API_FLAG_ADMIN_UP, 
			 2 => IfStatusFlags::IF_STATUS_API_FLAG_LINK_UP, 
			_ => panic!("Invalid Enum Descriminant")
		 }
	 }
	 fn size_of_enum_flag() -> u32{
		 32 as u32
	}
}
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)] 
#[repr(u32)]
pub enum MtuProto { 
	 MTU_PROTO_API_L3=0, 
	 MTU_PROTO_API_IP4=1, 
	 MTU_PROTO_API_IP6=2, 
	 MTU_PROTO_API_MPLS=3, 
} 
impl Default for MtuProto { 
	fn default() -> Self { MtuProto::MTU_PROTO_API_L3 }
}
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)] 
#[repr(u32)]
pub enum LinkDuplex { 
	 LINK_DUPLEX_API_UNKNOWN=0, 
	 LINK_DUPLEX_API_HALF=1, 
	 LINK_DUPLEX_API_FULL=2, 
} 
impl Default for LinkDuplex { 
	fn default() -> Self { LinkDuplex::LINK_DUPLEX_API_UNKNOWN }
}
#[derive(Debug,Serialize, Deserialize, Clone, Copy)] 
pub enum SubIfFlags { 
	 SUB_IF_API_FLAG_NO_TAGS=1, 
	 SUB_IF_API_FLAG_ONE_TAG=2, 
	 SUB_IF_API_FLAG_TWO_TAGS=4, 
	 SUB_IF_API_FLAG_DOT1AD=8, 
	 SUB_IF_API_FLAG_EXACT_MATCH=16, 
	 SUB_IF_API_FLAG_DEFAULT=32, 
	 SUB_IF_API_FLAG_OUTER_VLAN_ID_ANY=64, 
	 SUB_IF_API_FLAG_INNER_VLAN_ID_ANY=128, 
	 SUB_IF_API_FLAG_MASK_VNET=254, 
	 SUB_IF_API_FLAG_DOT1AH=256, 
} 
impl Default for SubIfFlags { 
	fn default() -> Self { SubIfFlags::SUB_IF_API_FLAG_NO_TAGS }
}
impl AsEnumFlag for SubIfFlags {
	 fn as_u32(data: &Self) -> u32{
		 *data as u32
	 }
	 fn from_u32(data: u32) -> Self{
		 match data{
			 1 => SubIfFlags::SUB_IF_API_FLAG_NO_TAGS, 
			 2 => SubIfFlags::SUB_IF_API_FLAG_ONE_TAG, 
			 4 => SubIfFlags::SUB_IF_API_FLAG_TWO_TAGS, 
			 8 => SubIfFlags::SUB_IF_API_FLAG_DOT1AD, 
			 16 => SubIfFlags::SUB_IF_API_FLAG_EXACT_MATCH, 
			 32 => SubIfFlags::SUB_IF_API_FLAG_DEFAULT, 
			 64 => SubIfFlags::SUB_IF_API_FLAG_OUTER_VLAN_ID_ANY, 
			 128 => SubIfFlags::SUB_IF_API_FLAG_INNER_VLAN_ID_ANY, 
			 254 => SubIfFlags::SUB_IF_API_FLAG_MASK_VNET, 
			 256 => SubIfFlags::SUB_IF_API_FLAG_DOT1AH, 
			_ => panic!("Invalid Enum Descriminant")
		 }
	 }
	 fn size_of_enum_flag() -> u32{
		 32 as u32
	}
}
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)] 
#[repr(u32)]
pub enum RxMode { 
	 RX_MODE_API_UNKNOWN=0, 
	 RX_MODE_API_POLLING=1, 
	 RX_MODE_API_INTERRUPT=2, 
	 RX_MODE_API_ADAPTIVE=3, 
	 RX_MODE_API_DEFAULT=4, 
} 
impl Default for RxMode { 
	fn default() -> Self { RxMode::RX_MODE_API_UNKNOWN }
}
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)] 
#[repr(u32)]
pub enum IfType { 
	 IF_API_TYPE_HARDWARE=0, 
	 IF_API_TYPE_SUB=1, 
	 IF_API_TYPE_P2P=2, 
	 IF_API_TYPE_PIPE=3, 
} 
impl Default for IfType { 
	fn default() -> Self { IfType::IF_API_TYPE_HARDWARE }
}
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)] 
#[repr(u8)]
pub enum Direction { 
	 RX=0, 
	 TX=1, 
} 
impl Default for Direction { 
	fn default() -> Self { Direction::RX }
}
pub type InterfaceIndex=u32; 
