/*
   Autogenerated Data, Do not Edit!
*/
#![allow(dead_code,unused_mut,unused_variables,unused_must_use,non_camel_case_types,unused_imports,non_snake_case)]
use vpp_api_macros::{VppMessage,VppUnionIdent};
use std::convert::TryInto;
use serde::{de::DeserializeOwned, Deserialize, Serialize};
pub use vpp_api_encoding::typ::*;
pub use vpp_api_encoding;
use vpp_api_message::VppApiMessage;
use serde_repr::{Serialize_repr, Deserialize_repr};
use typenum;
use crate::ip_types::*;
use crate::interface_types::*;
// Implementation for tunnel
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Tunnel {
	pub instance: u32,
	pub src: Address,
	pub dst: Address,
	pub sw_if_index: InterfaceIndex,
	pub table_id: u32,
	pub encap_decap_flags: EnumFlag<TunnelEncapDecapFlags>,
	pub mode: TunnelMode,
	pub flags: EnumFlag<TunnelFlags>,
	pub dscp: IpDscp,
	pub hop_limit: u8,
}
#[derive(Debug, Serialize, Deserialize, Clone, Copy, PartialEq)]
pub enum TunnelEncapDecapFlags {
	 TUNNEL_API_ENCAP_DECAP_FLAG_NONE=0,
	 TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_COPY_DF=1,
	 TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_SET_DF=2,
	 TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_COPY_DSCP=4,
	 TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_COPY_ECN=8,
	 TUNNEL_API_ENCAP_DECAP_FLAG_DECAP_COPY_ECN=16,
	 TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_INNER_HASH=32,
	 TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_COPY_HOP_LIMIT=64,
	 TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_COPY_FLOW_LABEL=128,
}
impl Default for TunnelEncapDecapFlags {
	fn default() -> Self { TunnelEncapDecapFlags::TUNNEL_API_ENCAP_DECAP_FLAG_NONE }
}
impl AsEnumFlag for TunnelEncapDecapFlags {
	 fn as_u32(data: &Self) -> u32{
		 *data as u32
	 }
	 fn from_u32(data: u32) -> Self{
		 match data{
			 0 => TunnelEncapDecapFlags::TUNNEL_API_ENCAP_DECAP_FLAG_NONE,
			 1 => TunnelEncapDecapFlags::TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_COPY_DF,
			 2 => TunnelEncapDecapFlags::TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_SET_DF,
			 4 => TunnelEncapDecapFlags::TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_COPY_DSCP,
			 8 => TunnelEncapDecapFlags::TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_COPY_ECN,
			 16 => TunnelEncapDecapFlags::TUNNEL_API_ENCAP_DECAP_FLAG_DECAP_COPY_ECN,
			 32 => TunnelEncapDecapFlags::TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_INNER_HASH,
			 64 => TunnelEncapDecapFlags::TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_COPY_HOP_LIMIT,
			 128 => TunnelEncapDecapFlags::TUNNEL_API_ENCAP_DECAP_FLAG_ENCAP_COPY_FLOW_LABEL,
			_ => panic!("Invalid Enum Descriminant")
		 }
	 }
	 fn size_of_enum_flag() -> u32{
		 8 as u32
	}
}
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)]
#[repr(u8)]
pub enum TunnelMode {
	 TUNNEL_API_MODE_P2P=0,
	 TUNNEL_API_MODE_MP=1,
}
impl Default for TunnelMode {
	fn default() -> Self { TunnelMode::TUNNEL_API_MODE_P2P }
}
#[derive(Debug, Serialize, Deserialize, Clone, Copy, PartialEq)]
pub enum TunnelFlags {
	 TUNNEL_API_FLAG_TRACK_MTU=1,
}
impl Default for TunnelFlags {
	fn default() -> Self { TunnelFlags::TUNNEL_API_FLAG_TRACK_MTU }
}
impl AsEnumFlag for TunnelFlags {
	 fn as_u32(data: &Self) -> u32{
		 *data as u32
	 }
	 fn from_u32(data: u32) -> Self{
		 match data{
			 1 => TunnelFlags::TUNNEL_API_FLAG_TRACK_MTU,
			_ => panic!("Invalid Enum Descriminant")
		 }
	 }
	 fn size_of_enum_flag() -> u32{
		 8 as u32
	}
}
